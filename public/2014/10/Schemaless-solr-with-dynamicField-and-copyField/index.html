<!DOCTYPE html>
<html lang="en">
<head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# website: http://ogp.me/ns/website#">
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
	<meta name="description" content="">
	<meta property="og:title" content="&#34;Schemaless&#34; solr with dynamicField and copyField">
	<link rel="icon" href="http://robotlibrarian.billdueber.com/" />
	
	
		<title>Robot Librarian | &#34;Schemaless&#34; solr with dynamicField and copyField</title>
		<meta property="og:type" content="article">
		<meta property="article:published_time" content= 2014-10-06 >
	
	<meta property="og:description" content="">
	<meta property="og:url" content="http://robotlibrarian.billdueber.com/2014/10/schemaless-solr-with-dynamicfield-and-copyfield/">
	<meta property="og:site_name" content="Robot Librarian">
	
		<meta property="og:tags" content="solr">
	
	<meta name="generator" content="Hugo 0.24.1" />
   
	
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.3.0/css/font-awesome.min.css">

	
	<link rel="stylesheet" href="http://robotlibrarian.billdueber.comcss/style.css">
	<link href="" rel="alternate" type="application/rss+xml" title="Robot Librarian" />
</head>
<nav class="navbar navbar-default navbar-fixed-top visible-xs">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			
				<a class="navbar-brand" href="http://robotlibrarian.billdueber.com">Robot Librarian</a>
			
		</div>
		<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
			<ul class="nav navbar-nav">
				
				
			</ul>
		</div>
	</div>
</nav>
<div class="container-fluid">
	<div class="row">
		<div id="menu" class="hidden-xs col-sm-4 col-md-3">
	<div id="particles-js"></div>
	<div id="menu-content" class="vertical-align">
		<img src="/images/robot_alpha.png" class="center-block" alt="Cheesy picture of robot">
		
			<h1 class="text-center"><a href="http://robotlibrarian.billdueber.com">Robot Librarian</a></h1>
		
		
		
			<small class="text-center center-block">Bill Dueber</small>
		
		
		
		<div id="social" class="text-center">
			<a href="https://twitter.com/billdueber" target="_blank"><i class="fa fa-twitter fa-2x"></i></a>
				
			
			
			
			<a href="https://github.com/https://github.com/billdueber" target="_blank"><i class="fa fa-github-square fa-2x"></i></a>
			
				
			<a href="mailto:bill@dueber.com" target="_blank"><i class="fa fa-envelope fa-2x"></i></a>			
		</div>
		<div id="links" class="text-center">
			
			
		</div>
	</div>
</div>


		<div id="content" class="col-xs-12 col-sm-8 col-md-9">
			<div class="row">
				<div id="post" class="col-sm-offset-1 col-sm-10 col-md-10 col-lg-8">

<main>
	<header>
		<div class="panel-header">
			<h1>&#34;Schemaless&#34; solr with dynamicField and copyField
				
			</h1>
			<div class="panel-footer">
				
					<small class="text-muted">
						
						
							<font size="4"><a href="http://robotlibrarian.billdueber.comtags/solr"><span class="label label-success">solr</span></a></font>
						
					</small>
				
			</div>
			
		</div>
	</header>
	<br>
	<HR align=center>
	<article>
		

<p>[Holy Kamoly, it&rsquo;s been a long time since I blogged!]</p>

<p>Recent versions of <a href="https://lucene.apache.org/solr/">solr</a> have the option to run in what they call <a href="https://cwiki.apache.org/confluence/display/solr/Schemaless+Mode">&ldquo;schemaless mode&rdquo;</a>, wherein fields that aren&rsquo;t recognized are actually added, automatically, to the schema as real named fields.</p>

<p>I find this intruguing, but it&rsquo;s not what I&rsquo;m after right now.</p>

<p>The problem I&rsquo;m in the first stages of addressing is that my <code>schema.xml</code> is huge mess &ndash; very little consistency, no naming conventions dictating what&rsquo;s stored/indexed, etc. It grew &ldquo;ogranically&rdquo; (which is what I say when I mean I&rsquo;ve been lazy and sloppy) and needs a full-on reorganization.</p>

<p>The way people tend to address this is with strict naming conventions (possibly using <a href="https://cwiki.apache.org/confluence/display/solr/Dynamic+Fields">dynamicField</a> ) and judicious use of <a href="https://cwiki.apache.org/confluence/display/solr/Copying+Fields">copyField</a> directives. The <a href="http://projecthydra.org/">Project Hydra</a> folks have <a href="https://github.com/projecthydra/hydra/wiki/Solr-Schema">a nice, straightforward system</a> for how they set up dynamic fields.</p>

<h2 id="indexed-xor-stored">Indexed XOR Stored?</h2>

<p>The more I thought about it, the more I wondered whether it might be useful to have a <em>strict separation of stored and indexed fields</em>. Indexed fields would be named with an appropriate suffix, so you know how they&rsquo;ve been analyzed. And stored fields would have pleasant, human-readable names to make them easy to deal with for consuming applications.</p>

<p>What I <em>think</em> I&rsquo;d like is a system where:</p>

<ul>
<li>All stored fields have &lsquo;bare&rsquo; names (e.g., &lsquo;title&rsquo;, not &lsquo;title_t&rsquo; or &lsquo;title_s&rsquo;)</li>
<li>All indexed fields are typed according to their name (so I know &lsquo;title_t&rsquo; is an indexed field of type &ldquo;text&rdquo;)</li>
<li>Separation of stored and indexed fields &ndash; a field is either stored or indexed, but not both.</li>
<li>A &ldquo;schemaless&rdquo; setup, where I don&rsquo;t need to define all (any of?) my fields in my schema and reboot solr when I make a change.</li>
</ul>

<p>To be clear: I&rsquo;m not sure this is a great way to go as of yet. But I figured out what I think is a good way to do it, should it turn out to be worthwhile.</p>

<h2 id="part-1-dynamic-fields">Part 1: Dynamic Fields</h2>

<p>Solr allows one to define dynamic fields &ndash; a field whose type is determined by a glob-match on its name. Instead of explicitly naming your field in your schema, you can do something like:</p>

<pre><code class="language-xml">&lt;dynamicField name=&quot;*_is&quot; type=&quot;int&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt;
</code></pre>

<p>&hellip;to indicate that any unrecognized field whose name ends in <code>_is</code> will treated as an indexed, stored integer.</p>

<p>Dynamic Field definitions are processed in order of declaration; first one wins. That allows you to define a &ldquo;default&rdquo; as the very last <code>dynamicField</code> that matches <em>anything</em> (e.g., <code>*</code>). The <code>schema.xml</code> that ships with Solr suggests that you can use this functionality to just ignore unrecognized fields.</p>

<pre><code class="language-xml">&lt;dynamicField name=&quot;*&quot; type=&quot;ignored&quot; multiValued=&quot;true&quot; /&gt;
</code></pre>

<p>But that gives me an idea.</p>

<h2 id="part-2-copy-fields">Part 2: Copy Fields</h2>

<p>The <code>copyField</code> directive allows you to index the same text into multiple fields (presumably with different analysis chains). Index data into one field, it automatically gets copied into another.</p>

<pre><code class="language-xml">
&lt;field name=&quot;title&quot; type=&quot;text&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;
&lt;field name=&quot;title_l&quot; type=&quot;text_leftanchored&quot; indexed=&quot;true&quot; stored=&quot;false&quot;/&gt;

&lt;copyField source=&quot;title&quot; dest=&quot;title_l&quot;/&gt;

</code></pre>

<p>In this case, even though I only send a <code>title</code>, the indexed field <code>title_l</code> will automatically be created and available for me to search against. Nice.</p>

<h2 id="part-3-copy-field-with-globs">Part 3: Copy Field with globs</h2>

<p>But it gets better. You can have globs (<code>*</code>) in your copyField source or destination attributes.</p>

<pre><code class="language-xml">&lt;!-- Copy all text fields (those that end in '_t') into 'keywords' --&gt;
&lt;copyField source=&quot;*_t&quot; dest=&quot;keywords&quot;/&gt;
</code></pre>

<p>So that&rsquo;s nice. But what if you have globs in both the source and the destination? The docs say:</p>

<blockquote>
<p>The copyField command can use a wildcard (*) character in the dest parameter only if the source parameter contains one as well. copyField uses the matching glob from the source field for the dest field name into which the source content is copied.</p>
</blockquote>

<p>Hmmmmmm&hellip;.</p>

<h2 id="part-4-putting-it-all-together">Part 4: Putting it all together</h2>

<p>Once I read that, I thought, &ldquo;Huh. I&rsquo;m hungry.&rdquo;</p>

<p>But after lunch, I thought, &ldquo;Maybe I can do something with this.&rdquo;</p>

<p>Here&rsquo;s what I came up with.</p>

<pre><code class="language-xml">&lt;dynamicField name=&quot;*_t_s&quot; type=&quot;text&quot; indexed=&quot;false&quot; stored=&quot;false&quot; multiValued=&quot;true&quot;/&gt;
&lt;dynamicField name=&quot;*_t&quot; type=&quot;text&quot; indexed=&quot;true&quot; stored=&quot;false&quot;/&gt;

&lt;copyField source=&quot;*_t_s&quot; dest=&quot;*_t&quot;/&gt;
&lt;copyField source=&quot;*_t_s&quot; dest=&quot;*&quot;/&gt;

&lt;!-- The default: a multivalued, stored, non-indexed string --&gt;
&lt;dynamicField name=&quot;*&quot; type=&quot;string&quot; indexed=&quot;false&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt;
</code></pre>

<p>Let&rsquo;s walk through that.</p>

<p>First, there are two <code>dynamicField</code> definitions. The first is a no-op: unstored, unindexed. We use it only for copying. The second is a standard indexed (but not stored) text field.</p>

<p>Then come the <code>copyField</code>s, where we match on the suffixes of the field types.
Finally, we have our default: a stored, unindexed string. (Note that when Solr stores a value, it stores whatever you put into it, not the value after analysis &ndash; same as a String does anyway).</p>

<p>Suppose I index an undeclared field called <code>title_t_s</code>:</p>

<ul>
<li><code>title_t_s</code> matches the first <code>dynamicField</code> declaration. This specific field is ignored (no indexing, no storing), but the text sent to it remains available for further processing by the <code>copyField</code>s.</li>
<li>The first <code>copyField</code> matches, and copies the text into newly-generated field formed by what matched the <code>*</code> in the source field, followed by <code>_t</code>. That&rsquo;s <code>title</code>, so we get <code>title_t</code>.</li>
<li>The newly-minted <code>title_t</code> field is also unrecognized, but it matches the <em>second</em> <code>dynamicField</code> and is thus assigned to be an indexed text field.</li>
<li>Meanwhile, the second <code>copyField</code> <em>also</em> matches our original <code>title_t_s</code>. It uses what matched against the <code>*</code> in the source (<code>title</code>, again) to create a new field just called <code>title</code>.</li>
<li>Now we have a new field called <code>title</code> not matching any declared field, so it runs down the list of <code>dynamicField</code> definitions until it hits our stopgap at the end: a stored, nonindexed string.</li>
</ul>

<p>Yeah, like that wasn&rsquo;t confusing.</p>

<p>The result is what&rsquo;s important, though. What we end up with field-wise is:</p>

<ul>
<li><code>title_t_s</code> disappearing into the ether. It&rsquo;s just gone.</li>
<li><code>title_t</code>, an indexed text field</li>
<li><code>title</code>, a stored string.</li>
</ul>

<p>Now I can run searches against <code>title_t</code>, but my document will have a nice stored string in it just called <code>title</code>.</p>

<h2 id="why-this-is-probably-a-bad-idea">Why this is probably a bad idea.</h2>

<p>Depending on how crazy you want to get options-wise (multi-valued or not, termVectors or not, etc.) you can get a combinatorial explosion on the number of <code>dynamicField</code>/<code>copyField</code> sets you need to generate. But that&rsquo;s not the real problem.</p>

<p>The real problem is that you don&rsquo;t have <em>any</em> intrinsic documentation of what your index looks like. None. You can&rsquo;t even look at the indexing code, because it&rsquo;ll look like you&rsquo;re sending a document with a field called <code>title_t_s</code> and that field is nowhere to be found.</p>

<p>So, like I said: interesting, but by no means the obvious way to go. Still, I&rsquo;m sure I&rsquo;ll have some variant of this in my schema when it comes time for me to reboot the library catalog.</p>

	</article>
	<br>
	
</main>
	


						<br>
						<section id="footer">
							<div class="text-center center-block">
								<ul class="copyright">
									<li>&copy; 2017 <a target="_blank" href="http://robotlibrarian.billdueber.com"></a> | Powered by <a target="_blank" href="https://gohugo.io/">Gohugo</a> | Theme <a target="_blank" href="https://git.pofilo.fr/pofilo/hugo-fatboy">Fatboy</a></li>
								</ul>
							</div>
						</section>
					</div>
				</div>
			</div>
		</div>
	</div>
  
  
	
  
	<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
	<script src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.2/js/bootstrap.min.js"></script>

	

	

	

	

	
	</body>
</html>





