<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Solr on Robot Librarian</title>
    <link>http://robotlibrarian.billdueber.com/tags/solr/</link>
    <description>Recent content in Solr on Robot Librarian</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 06 Oct 2014 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://robotlibrarian.billdueber.com/tags/solr/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>&#34;Schemaless&#34; solr with dynamicField and copyField</title>
      <link>http://robotlibrarian.billdueber.com/2014/10/schemaless-solr-with-dynamicfield-and-copyfield/</link>
      <pubDate>Mon, 06 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://robotlibrarian.billdueber.com/2014/10/schemaless-solr-with-dynamicfield-and-copyfield/</guid>
      <description>[Holy Kamoly, it&amp;rsquo;s been a long time since I blogged!]
Recent versions of solr have the option to run in what they call &amp;ldquo;schemaless mode&amp;rdquo;, wherein fields that aren&amp;rsquo;t recognized are actually added, automatically, to the schema as real named fields.
I find this intruguing, but it&amp;rsquo;s not what I&amp;rsquo;m after right now.
The problem I&amp;rsquo;m in the first stages of addressing is that my schema.xml is huge mess &amp;ndash; very little consistency, no naming conventions dictating what&amp;rsquo;s stored/indexed, etc.</description>
    </item>
    
    <item>
      <title>Boosting on Exactish (anchored) phrase matching in Solr: (SST #4)</title>
      <link>http://robotlibrarian.billdueber.com/2012/03/boosting-on-exactish-anchored-phrase-matching-in-solr-sst-4/</link>
      <pubDate>Mon, 19 Mar 2012 00:00:00 +0000</pubDate>
      
      <guid>http://robotlibrarian.billdueber.com/2012/03/boosting-on-exactish-anchored-phrase-matching-in-solr-sst-4/</guid>
      <description>Check out introduction to the Stupid Solr Tricks series if you&amp;rsquo;re just joining us.]
 Exact matching in Solr is easy. Use the default string type: all it does is, essentially, exact phrase matching. string is a great type for faceted values, where the only way we expect to search the index is via text pulled from the index itself. Query the index to get a value: use that value to re-query the index.</description>
    </item>
    
    <item>
      <title>Requiring/Preferring searches that don&#39;t span multiple values (SST #3)</title>
      <link>http://robotlibrarian.billdueber.com/2012/03/requiringpreferring-searches-that-dont-span-multiple-values-sst-3/</link>
      <pubDate>Fri, 09 Mar 2012 00:00:00 +0000</pubDate>
      
      <guid>http://robotlibrarian.billdueber.com/2012/03/requiringpreferring-searches-that-dont-span-multiple-values-sst-3/</guid>
      <description>Check out introduction to the Stupid Solr Tricks series if you&amp;rsquo;re just joining us.]
 Solr and multiValued fields Here&amp;rsquo;s another thing you need to understand about Solr: it doesn&amp;rsquo;t really have fields that can take multiple values.
&amp;ldquo;But Bill,&amp;rdquo; you&amp;rsquo;re saying, &amp;ldquo;sure it does. I mean, hell, it even has a &amp;lsquo;multiValued&amp;rsquo; parameter.&amp;rdquo;
First off: watch your language.
Second off: are you sure?
Let&amp;rsquo;s do a quick test.</description>
    </item>
    
    <item>
      <title>Using localparams in Solr (or, how to boost records that contain all terms) (SST #2)</title>
      <link>http://robotlibrarian.billdueber.com/2012/03/using-localparams-in-solr-sst-2/</link>
      <pubDate>Tue, 06 Mar 2012 00:00:00 +0000</pubDate>
      
      <guid>http://robotlibrarian.billdueber.com/2012/03/using-localparams-in-solr-sst-2/</guid>
      <description>[Note: this isn&amp;rsquo;t so much a Stupid Solr Trick as a Thing You Should Probably Know; consider it required reading for the next SST. If you&amp;rsquo;re just joining us, check out the introduction to the Stupid Solr Tricks series]
What the heck is a localparams query? A garden-variety Solr query URL looks something like this:
 http://localhost:8983/solr/select? defType=dismax &amp;amp;amp;qf=name^2 place^1 &amp;amp;amp;q=Dueber ~~~~ Which is fine, as far as it goes.</description>
    </item>
    
    <item>
      <title>Solr Field Type for numeric(ish) IDs (SST #1)</title>
      <link>http://robotlibrarian.billdueber.com/2012/03/solr-field-type-for-numericish-ids/</link>
      <pubDate>Thu, 01 Mar 2012 00:00:00 +0000</pubDate>
      
      <guid>http://robotlibrarian.billdueber.com/2012/03/solr-field-type-for-numericish-ids/</guid>
      <description>[For the introduction to this series, take a quick gander at the introduction]
Like everyone else in the library world, I&amp;rsquo;ve got a bunch of well-defined, well-controlled standard identifiers I need to keep track of and allow searching on.
You know, well-vetted stuff like this:
 1234-5678 123-4567-890 12-34-567-X 0012-0045 ISBN13: 1234567890123 ISSN: 1234567X (1998-99) ISSN (1998-99): 1234567X 1234567890 (hdk. 22 pgs) 9 Behind the 3rd floor desk Henry VIII  [Note: some of these may be a titch exaggerated]</description>
    </item>
    
    <item>
      <title>Stupid Solr tricks: Introduction (SST #0)</title>
      <link>http://robotlibrarian.billdueber.com/2012/02/stupid-solr-tricks-introduction/</link>
      <pubDate>Wed, 29 Feb 2012 00:00:00 +0000</pubDate>
      
      <guid>http://robotlibrarian.billdueber.com/2012/02/stupid-solr-tricks-introduction/</guid>
      <description>Completed parts of the series:
 A Solr Field Type for numeric(ish) IDs Using localparams in Solr (or, how to boost records that contain all terms) Requiring/Preferring searches that don&amp;rsquo;t span multiple values Boosting on Exactish (anchored) phrase matching  Those of you who read this blog regularly (Hi Mom!) know that while we do a lot of stuff at the University of Michigan Library, our bread-and-butter these days are projects that center around Solr.</description>
    </item>
    
  </channel>
</rss>